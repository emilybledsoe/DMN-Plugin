import { createVNode, createComponentVNode } from "inferno";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { Component } from 'inferno';
import { assign, isFunction } from 'min-dash';
import { inject } from '../../../components';
import { query as domQuery } from 'min-dom';
import { setRange } from 'selection-ranges';
/**
 * @typedef ContextMenuPosition
 * @property {number} x
 * @property {number} y
 * @property {number} [width=0]
 * @property {number} [height=0]
 * @property {'bottom-left'|'bottom-right'|'top-left'|'top-right'} [align]
 */

var ContextMenuComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(ContextMenuComponent, _Component);

  function ContextMenuComponent(props, _context) {
    var _this;

    _classCallCheck(this, ContextMenuComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextMenuComponent).call(this, props, _context));

    _defineProperty(_assertThisInitialized(_this), "open", function (_ref) {
      var position = _ref.position,
          context = _ref.context;

      // always close first
      _this.close();

      _this.setState({
        isOpen: true,
        position: position || {
          x: 0,
          y: 0
        },
        context: context || {}
      });
    });

    _defineProperty(_assertThisInitialized(_this), "close", function () {
      if (_this.state.isOpen) {
        _this.setState({
          context: undefined,
          isOpen: false,
          position: {
            x: 0,
            y: 0
          }
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "triggerClose", function () {
      _this.eventBus.fire('contextMenu.close');
    });

    _this.state = {
      isOpen: false,
      position: {
        x: 0,
        y: 0
      }
    };
    inject(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Open the context menu with given position and context.
   *
   * The menu itself will figure out the best position, taking the optional
   * positioning parameter into account. Position can also contain indicator
   * in which direction to open context menu.
   *
   * @param {ContextMenuPosition} position
   * @param {Object} [context]
   */


  _createClass(ContextMenuComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.eventBus.on('contextMenu.open', this.open);
      this.eventBus.on('contextMenu.close', this.close);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.eventBus.off('contextMenu.open', this.open);
      this.eventBus.off('contextMenu.close', this.close);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          isOpen = _this$state.isOpen,
          context = _this$state.context,
          position = _this$state.position;

      if (!isOpen) {
        return null;
      }

      var components = this.components.getComponents('context-menu', context);

      if (!components.length) {
        return null;
      }

      return createComponentVNode(2, ContextMenu, {
        "className": "context-menu no-deselect",
        "context": context,
        "position": position,
        "offset": context.offset || {
          x: 0,
          y: 0
        },
        "autoFocus": context.autoFocus !== false,
        "autoClose": context.autoClose !== false,
        "components": components,
        "onClose": this.triggerClose
      });
    }
  }]);

  return ContextMenuComponent;
}(Component);

export { ContextMenuComponent as default };
ContextMenuComponent.$inject = ['eventBus', 'components'];
/**
 * Low-level, stateless context menu holder.
 */

var ContextMenu =
/*#__PURE__*/
function (_Component2) {
  _inherits(ContextMenu, _Component2);

  function ContextMenu(props, context) {
    var _this2;

    _classCallCheck(this, ContextMenu);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ContextMenu).call(this, props, context));

    _defineProperty(_assertThisInitialized(_this2), "onGlobalMouseDown", function (event) {
      _this2.checkClose(event.target);
    });

    _defineProperty(_assertThisInitialized(_this2), "onGlobalKey", function (event) {
      var keyCode = event.which; // ENTER or ESC

      if (keyCode === 13 || keyCode === 27) {
        event.stopPropagation();
        event.preventDefault();

        _this2.close();
      }
    });

    _defineProperty(_assertThisInitialized(_this2), "onFocusChanged", function (event) {
      _this2.checkClose(event.target);
    });

    _defineProperty(_assertThisInitialized(_this2), "setNode", function (node) {
      _this2.node = node;
      var autoFocus = _this2.props.autoFocus;

      if (node) {
        _this2.updatePosition();

        if (autoFocus) {
          ensureFocus(node);
        }
      }
    });

    inject(_assertThisInitialized(_this2));
    return _this2;
  }

  _createClass(ContextMenu, [{
    key: "close",
    value: function close() {
      var onClose = this.props.onClose;

      if (isFunction(onClose)) {
        onClose();
      }
    }
    /**
     * Check whether closing the context menu is necessary
     * after selecting the given element.
     */

  }, {
    key: "checkClose",
    value: function checkClose(focusTarget) {
      var autoClose = this.props.autoClose;

      if (!autoClose) {
        return;
      }

      var node = this.node;

      if (!node) {
        return;
      }

      if (node === focusTarget) {
        return;
      }

      if (node.contains(focusTarget)) {
        return;
      }

      this.close();
    }
    /**
     * Handle global (window) mousedown event.
     */

  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      document.addEventListener('focusin', this.onFocusChanged);
      document.addEventListener('keydown', this.onGlobalKey);
      document.addEventListener('mousedown', this.onGlobalMouseDown);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('focusin', this.onFocusChanged);
      document.removeEventListener('keydown', this.onGlobalKey);
      document.removeEventListener('mousedown', this.onGlobalMouseDown);
    }
  }, {
    key: "updatePosition",

    /**
     * Find best context menu position and re-layout accordingly.
     */
    value: function updatePosition() {
      var _this$props = this.props,
          position = _this$props.position,
          offset = _this$props.offset;
      var bounds = this.node.getBoundingClientRect();

      if (!position.width) {
        position.width = 0;
      }

      if (!position.height) {
        position.height = 0;
      }

      var container = this.renderer.getContainer();
      var containerBounds = container.getBoundingClientRect();

      if (containerBounds.width > containerBounds.height) {
        this.node.classList.add('horizontal');
        this.node.classList.remove('vertical');
      } else {
        this.node.classList.add('vertical');
        this.node.classList.remove('horizontal');
      }

      var scrollLeft = container.scrollLeft,
          scrollTop = container.scrollTop;
      var style = {};
      var alignment;

      if (position.align) {
        alignment = position.align.split('-');
      }

      var left, top;
      var horizontalAlignment = alignment && alignment[1] || (position.x + position.width / 2 > containerBounds.width / 2 ? 'left' : 'right');

      if (horizontalAlignment === 'left') {
        left = position.x - containerBounds.left - bounds.width + offset.x + scrollLeft;
      } else {
        left = window.scrollX - containerBounds.left + position.x + position.width - offset.x + scrollLeft;
      }

      left = alignment ? left : clampNumber(left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);
      style.left = left + 'px';
      var verticalAlignment = alignment && alignment[0] || (position.y + position.height / 2 > containerBounds.height / 2 ? 'top' : 'bottom');

      if (verticalAlignment === 'top') {
        top = position.y - containerBounds.top - bounds.height + offset.y + scrollTop;
      } else {
        top = window.scrollY - containerBounds.top + position.y - offset.y + scrollTop;
      }

      top = alignment ? top : clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);
      style.top = top + 'px'; // ensure context menu will always be accessible

      style.overflowY = 'auto';
      style.maxHeight = containerBounds.height - top + scrollTop + 'px';
      assign(this.node.style, style);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          context = _this$props2.context,
          components = _this$props2.components,
          className = _this$props2.className;
      return createVNode(1, "div", className, components.map(function (Component, idx) {
        return createComponentVNode(2, Component, {
          "context": context
        }, idx);
      }), 0, {
        "onContextMenu": function onContextMenu(e) {
          return e.preventDefault();
        }
      }, null, this.setNode);
    }
  }]);

  return ContextMenu;
}(Component);

ContextMenu.$inject = ['renderer']; // helpers /////////////

function clampNumber(number, min, max) {
  return Math.max(min, Math.min(max, number));
}

var SELECTABLE_ELEMENTS = "\n  input[type=text],\n  input[type=number],\n  input[type=button],\n  input[type=submit],\n  [contenteditable],\n  [tabindex],\n  a[href],\n  textarea,\n  button\n";

function ensureFocus(el) {
  var focusEl = domQuery(SELECTABLE_ELEMENTS, el);

  if (focusEl) {
    focusEl.focus(); // inputs

    if (focusEl.selectionStart && focusEl.type === 'text') {
      focusEl.selectionStart = 100000;
    } else // content editable elements
      if ('contentEditable' in focusEl) {
        setRange(focusEl, {
          start: 100000,
          end: 100000
        });
      }
  }
}
//# sourceMappingURL=ContextMenuComponent.js.map